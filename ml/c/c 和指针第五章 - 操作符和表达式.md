# 操作符
移位操作有一个要注意：右移存在逻辑移位和算术移位。
1. 逻辑移位。左边用 0 填充
2. 算术移位。根据符号位，若是 1 就用 1 填充；若是 0 就用 0 填充。

无符号数是逻辑移位，而有符号数取决于编译器。所以若有符号数右移，不可移植。

## 赋值

```c
a = x = y + 3;
//
x = y + 3
a = x;
```
但是如果 y + 3 是整形，a 为 char，类似这种会发生截断的情况，那就会出异常

而如下这种复合型赋值，左值只需要计算一次
```c
a += 3 // a = a + 3 
```

## 单目操作符

sizeof：判断操作数类型字节数

同时，判断表达式长度不需要对表达式进行求值，`sizeof(a = b + 1)` 中 a 不会有赋值。

++、--：不论如何，这两个操作符操作的结果都不是之前所修改的变量，都是**变量值的拷贝**。所以 ++a = 10 不成立，++a 得到一个变量值得拷贝，本质是值。值 = 值 是错误的。

## 关系操作符

## 逻辑操作符
&& || 短路求值
& | 是没有短路求值的，需要左右操作数都求出值


## 条件操作符
```c
b[e / 2] = a > 5 ? 4 : d - 10
```

## 逗号操作符
逗号从左向右求值，最右的表达式就是整个逗号表达式的值
```c
b + 1, c /2. d > 0 // d > 0 的话就返回真
```
一种场景方便，不用再 while 前写关于 a 的东西：
```c
while(a = get_v(), count_value(a), a > 0) {
	...
}
```

## 下标引用、函数调用和结构成员
和其他章节会有链接
```c
array[x]
*(array + x)
```


# 布尔值
0 为假，非零为真。注意即使在 c++ 中也最好用这个， 而不是用 bool。


# 左值右值
左值：赋值符号左边的东西
右值：赋值符号右边的东西

左值得保证结果要存在确定位置。所以
```c
b + 25 = a;
```
这样是不可以的，b 的位置是不确定的。而
```c
int a[3];
a[b + 1] = 3;
```
这样是可以的，虽然左值也存在表达式。关键就在于左值存储的位置是否可确定。

左值位置可确定，合法。

而右值是一个值。

# 表达式求值
## 隐式类型转换
## 算术转换
操作符的操作数类型不同，需要其中一个转为另外一个操作数的类型。一般是低精度像高精度转换。

```c
int a = 5000;
int b = 25
long c = a * b // 可能 a* b 溢出，需要 (long)a * b
```

## 优先级和求值顺序
相邻操作符执行顺序根据：优先级先行，若一致，就根据结合性来。但是编译器可以自由决定对表达式求值，只要不违背操作符所施加的顺序。

```c
a * b + c * d + e * f;
// 1. a * b 2. c * d 3. a * b + c * d 4. e * f 5.  a * b + c * d + e * f
// 1. a * b 2. c * d 3. e * f 4. 全加
```

如上的例子就是， 多个 * 的优先级一致，不影响结合与顺序的情况下，两种方式都可以。