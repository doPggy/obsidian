## 不同作用域
1. 代码作用域。对于不同代码块申请的变量，由于他们不会同时存在，是存在共享内存地址的情况的。
2. 文件作用域
3. 原型作用域。针对函数原型中声明的参数名，可以与定义时的名字不一致，这个作用域下是不会冲突的。但是这么写肯定是不好的
4. 函数作用域。只适用于语句标签，而这个用于 goto

## 链接属性
目标文件[[链接]]时，标识符作用域是怎么样的，相同该如何

1. external。其他源文件声明同名变量，函数都是指向同一个实体
2. internal。只在当前文件中，所有声明都指向一个实体
3. none。

如下 b 和 c 就是缺省情况下为 external 的链接属性
```c
int b;
int c(..)
{
}
```

extern, static 用于修改链接属性。

static: 让缺省链接属性为 external 的声明改为 internal，在本文件私有。

extern：访问任何其他位置定义的实体。第一次使用 extern int k，就代表以后其他 extern  int k 就是访问这个源头 k 而不是新定义一个，同时不改变链接属性，即使是 internal 的声明。

## 存储类型
指存储变量值得==**内存类型**==。

自动、静态、寄存器类型。而变量缺省存储类型取决于 **声明位置**。

1. 静态：在代码块之外声明的变量会存储在静态内存。程序运行之前创建，程序结束之后销毁，但是初始化在程序执行的时候。

2. 自动(auto)：在代码块内部声明的变量会存储在堆栈，在程序执行到相应部分才创建。同时他们不具有链接属性。

3. 寄存器：用于自动变量声明。访问效率更高效。但是编译器可能对于 register 有自己的优化处理，例如多个 register 变量就存前几个进寄存器。

关于寄存器的使用，可以频率使用高的变量声明为寄存器变量，例如把一些指针变量声明为寄存器变量。

利用 static 可以让 auto 变量变为静态变量，这样即使这些变量在代码块内，也是存储在静态数据，这才有了一些统计调用函数次数的变量实现：
```c
int xxx()
{
	static int c = 0;
	c++;
}
```

## static 关键字
这个算一个总结。

注意，局部变量作用域会隐藏全局变量。



## 小结
局部变量：自动、无链接属性、作用域在当前代码块。
全局：所有代码块之外，可能跨文件。变量数据在静态内存不在堆栈。