# 内存地址

边界对齐：整型值存储的起始位置只能是某些特定字节，通常是 2、4 的倍数、

变量名来访问内存位置，但是这个是编译器实现的，底层还是通过地址访问


# 值和类型

# 指针变量的内容
指针变量存着地址，通过 * 操作符才能访问这个地址上的内存

# 间接访问操作符
指针访问他所指向的地址的过程就是间接访问。

指针存储的就是地址。

c 和指针对于指针的解释还是很好的。

# 未初始化和非法指针
指针变量和一般变量一样，如果没有初始化，存的值是一个随机的值。而这个值如果直接去间接调用，a 中的地址可能就是个非法内存，直接出事了。
```c
int *a;
*a = 12;
```

# NULL
可以用这个初始化未使用的指针变量。

# 指针、间接访问
```c
*&a = 25;
```
&a 是指针常量(记录的地址不得改变)

# 指针常量
地址 100 上的数据改成 10。
```c
*(int *)100 = 10;
```

# 指针的指针
```c
int a = 12;
int *b = &a;
int **c = &b;
```
操作符 * 结合性是从右向左 *(*c)

# 指针表达式
++ 返回的是一份拷贝，但是这份拷贝的位置不可知，所以作为左值有问题。
```c
++cp
```

首先要知道，后缀 ++ 优先于 *

前缀 ++ 和 * 同级。结合性从右向左。
```c
*++cp // 左值：cp 存的地址先加 1，然后返回这地址拷贝，然后再取内存
*cp++ // 左值：cp 先++，返回 cp 原来的值得拷贝，然后再取地址。
++*cp++ // 右值：++ 后，cp 返回原本值得拷贝，然后取地址数据，再 ++ 值
```


# 指针运算